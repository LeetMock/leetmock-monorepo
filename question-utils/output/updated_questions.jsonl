{"functionName": "twoSum", "evalMode": "SortedMatch", "inputParameters": {"python": ["nums", "List[int]", "target", "int"], "javascript": ["nums", "number[]", "target", "number"], "cpp": ["nums", "vector<int>&", "target", "int"], "java": ["nums", "int[]", "target", "int"]}, "tests": [{"input": {"nums": [2, 7, 11, 15], "target": 9}, "output": [0, 1]}, {"input": {"nums": [3, 2, 4], "target": 6}, "output": [1, 2]}, {"input": {"nums": [3, 3], "target": 6}, "output": [0, 1]}, {"input": {"nums": [1, 2, 3, 4, 5], "target": 9}, "output": [3, 4]}, {"input": {"nums": [-1, -2, -3, -4, -5], "target": -8}, "output": [2, 4]}], "title": "Two Sum", "question": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n\nFollow-up: Can you come up with an algorithm that is less than O(n^2) time complexity?", "difficulty": 1, "category": ["Array", "Hash Table"], "solutions": {"bruteForce": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == target - nums[i]:\n                    return [i, j]", "twoPassHashTable": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i in range(len(nums)):\n            hashmap[nums[i]] = i\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap and hashmap[complement] != i:\n                return [i, hashmap[complement]]", "onePassHashTable": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [i, hashmap[complement]]\n            hashmap[nums[i]] = i"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {number[], number}\n * @return {any}\n */\nvar twoSum = function(nums, target) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object twoSum(int[] nums, int target) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int twoSum(vector<int>& nums, int target) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "addTwoNumbers", "evalMode": "ListNodeIter", "inputParameters": {"python": ["l1", "Optional[ListNode]", "l2", "Optional[ListNode]"], "javascript": ["l1", "ListNode", "l2", "ListNode"], "cpp": ["l1", "ListNode*", "l2", "ListNode*"], "java": ["l1", "ListNode", "l2", "ListNode"]}, "tests": [{"input": {"l1": [2, 4, 3], "l2": [5, 6, 4]}, "output": [7, 0, 8]}, {"input": {"l1": [0], "l2": [0]}, "output": [0]}, {"input": {"l1": [9, 9, 9, 9, 9, 9, 9], "l2": [9, 9, 9, 9]}, "output": [8, 9, 9, 9, 0, 0, 0, 1]}], "title": "Add Two Numbers", "question": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\nConstraints:\n\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.", "difficulty": 2, "category": ["Linked List", "Math", "Recursion"], "solutions": {"elementaryMath": "class Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummyHead = ListNode(0)\n        curr = dummyHead\n        carry = 0\n        while l1 != None or l2 != None or carry != 0:\n            l1Val = l1.val if l1 else 0\n            l2Val = l2.val if l2 else 0\n            columnSum = l1Val + l2Val + carry\n            carry = columnSum // 10\n            newNode = ListNode(columnSum % 10)\n            curr.next = newNode\n            curr = newNode\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummyHead.next"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {ListNode, ListNode}\n * @return {any}\n */\nvar addTwoNumbers = function(l1, l2) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object addTwoNumbers(ListNode l1, ListNode l2) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int addTwoNumbers(ListNode* l1, ListNode* l2) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "isMatch", "evalMode": "SortedMatch", "inputParameters": {"python": ["s", "str", "p", "str"], "javascript": ["s", "string", "p", "string"], "cpp": ["s", "string", "p", "string"], "java": ["s", "String", "p", "String"]}, "tests": [{"input": {"s": "aa", "p": "a"}, "output": false}, {"input": {"s": "aa", "p": "a*"}, "output": true}, {"input": {"s": "ab", "p": ".*"}, "output": true}], "title": "Regular Expression Matching", "question": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\nExample 1:\n\nInput: s = 'aa', p = 'a'\nOutput: false\nExplanation: 'a' does not match the entire string 'aa'.\nExample 2:\n\nInput: s = 'aa', p = 'a*'\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\n\nInput: s = 'ab', p = '.*'\nOutput: true\nExplanation: '.*' means 'zero or more (*) of any character (.)'.\n\nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.", "difficulty": 3, "category": ["String", "Dynamic Programming", "Recursion"], "solutions": {"recursion": "class Solution(object):\n    def isMatch(self, text: str, pattern: str) -> bool:\n        if not pattern:\n            return not text\n\n        first_match = bool(text) and pattern[0] in {text[0], '.'}\n\n        if len(pattern) >= 2 and pattern[1] == '*':\n            return (\n                self.isMatch(text, pattern[2:])\n                or first_match\n                and self.isMatch(text[1:], pattern)\n            )\n        else:\n            return first_match and self.isMatch(text[1:], pattern[1:])", "dynamicProgrammingTopDown": "class Solution(object):\n    def isMatch(self, text: str, pattern: str) -> bool:\n        memo = {}\n\n        def dp(i: int, j: int) -> bool:\n            if (i, j) not in memo:\n                if j == len(pattern):\n                    ans = i == len(text)\n                else:\n                    first_match = i < len(text) and pattern[j] in {text[i], '.'}\n                    if j + 1 < len(pattern) and pattern[j + 1] == '*':\n                        ans = dp(i, j + 2) or first_match and dp(i + 1, j)\n                    else:\n                        ans = first_match and dp(i + 1, j + 1)\n\n                memo[i, j] = ans\n            return memo[i, j]\n\n        return dp(0, 0)", "dynamicProgrammingBottomUp": "class Solution(object):\n    def isMatch(self, text: str, pattern: str) -> bool:\n        dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)]\n\n        dp[-1][-1] = True\n        for i in range(len(text), -1, -1):\n            for j in range(len(pattern) - 1, -1, -1):\n                first_match = i < len(text) and pattern[j] in {text[i], '.'}\n                if j + 1 < len(pattern) and pattern[j + 1] == '*':\n                    dp[i][j] = dp[i][j + 2] or first_match and dp[i + 1][j]\n                else:\n                    dp[i][j] = first_match and dp[i + 1][j + 1]\n\n        return dp[0][0]"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def isMatch(self, s: str, p: str):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {string, string}\n * @return {any}\n */\nvar isMatch = function(s, p) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object isMatch(String s, String p) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int isMatch(string s, string p) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "largestNumber", "evalMode": "exactMatch", "inputParameters": {"python": ["nums", "List[int]"], "javascript": ["nums", "number[]"], "cpp": ["nums", "vector<int>&"], "java": ["nums", "int[]"]}, "tests": [{"input": {"nums": [10, 2]}, "output": "210"}, {"input": {"nums": [3, 30, 34, 5, 9]}, "output": "9534330"}], "title": "Largest Number", "question": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\nExample 1:\n\nInput: nums = [10,2]\nOutput: '210'\nExample 2:\n\nInput: nums = [3,30,34,5,9]\nOutput: '9534330'\n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 109", "difficulty": 2, "category": ["Array", "String", "Greedy", "Sorting"], "solutions": {"sortingViaCustomComparator": "class LargerNumKey(str):\n    def __lt__(x, y):\n        return x + y > y + x\n\n\nclass Solution:\n    def largestNumber(self, nums):\n        largest_num = \"\".join(sorted(map(str, nums), key=LargerNumKey))\n        return '0' if largest_num[0] == '0' else largest_num"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def largestNumber(self, nums: List[int]):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {number[]}\n * @return {any}\n */\nvar largestNumber = function(nums) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object largestNumber(int[] nums) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int largestNumber(vector<int>& nums) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "isSubtree", "evalMode": "exactMatch", "inputParameters": {"python": ["root", "Optional[TreeNode]", "subRoot", "Optional[TreeNode]"], "javascript": ["root", "TreeNode", "subRoot", "TreeNode"], "cpp": ["root", "TreeNode*", "subRoot", "TreeNode*"], "java": ["root", "TreeNode", "subRoot", "TreeNode"]}, "tests": [{"input": {"root": [3, 4, 5, 1, 2], "subRoot": [4, 1, 2]}, "output": true}, {"input": {"root": [3, 4, 5, 1, 2, null, null, null, null, 0], "subRoot": [4, 1, 2]}, "output": false}], "title": "Subtree of Another Tree", "question": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\n\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\n\nExample 1:\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n\nExample 2:\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n\nConstraints:\nThe number of nodes in the root tree is in the range [1, 2000].\nThe number of nodes in the subRoot tree is in the range [1, 1000].\n-104 <= root.val <= 104\n-104 <= subRoot.val <= 104", "difficulty": 1, "category": ["Tree", "Depth-First Search", "String Matching", "Binary Tree", "Hash Function"], "solutions": {"recursion": "class Solution:\n    \n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n\n        if self.sameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def sameTree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if root and subRoot and root.val == subRoot.val:\n            return self.sameTree(root.left, subRoot.left) and self.sameTree(root.right, subRoot.right)\n        return False"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {TreeNode, TreeNode}\n * @return {any}\n */\nvar isSubtree = function(root, subRoot) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object isSubtree(TreeNode root, TreeNode subRoot) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int isSubtree(TreeNode* root, TreeNode* subRoot) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "characterReplacement", "evalMode": "exactMatch", "inputParameters": {"python": ["s", "str", "k", "int"], "javascript": ["s", "string", "k", "number"], "cpp": ["s", "string", "k", "int"], "java": ["s", "String", "k", "int"]}, "tests": [{"input": {"s": "ABAB", "k": 2}, "output": 4}, {"input": {"s": "AABABBA", "k": 1}, "output": 4}], "title": "Longest Repeating Character Replacement", "question": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\n\nExample 1:\n\nInput: s = 'ABAB', k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\nExample 2:\n\nInput: s = 'AABABBA', k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form 'AABBBBA.\nThe substring 'BBBB' has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.\n\nConstraints:\n\n1 <= s.length <= 105\ns consists of only uppercase English letters.\n0 <= k <= s.length", "difficulty": 2, "category": ["Hash Table", "String", "Sliding Window"], "solutions": {"slidingWindow": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            if (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n\n        return (r - l + 1)"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {string, number}\n * @return {any}\n */\nvar characterReplacement = function(s, k) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object characterReplacement(String s, int k) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "maxCoins", "evalMode": "exactMatch", "inputParameters": {"python": ["nums", "List[int]"], "javascript": ["nums", "number[]"], "cpp": ["nums", "vector<int>&"], "java": ["nums", "int[]"]}, "tests": [{"input": {"nums": [3, 1, 5, 8]}, "output": 167}, {"input": {"nums": [1, 5]}, "output": 10}], "title": "Burst Balloons", "question": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.\n\nExample 1:\n\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\nExample 2:\n\nInput: nums = [1,5]\nOutput: 10\n\nConstraints:\n\nn == nums.length\n1 <= n <= 300\n0 <= nums[i] <= 100", "difficulty": 3, "category": ["Array", "Dynamic Programming"], "solutions": {"dynamicProgramming": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        cache = {}\n        nums = [1] + nums + [1]\n\n        for offset in range(2, len(nums)):\n            for left in range(len(nums) - offset):\n                right = left + offset\n                for pivot in range(left + 1, right):\n                    coins = nums[left] * nums[pivot] * nums[right]\n                    coins += cache.get((left, pivot), 0) + cache.get((pivot, right), 0)\n                    cache[(left, right)] = max(coins, cache.get((left, right), 0))\n        return cache.get((0, len(nums) - 1), 0)"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def maxCoins(self, nums: List[int]):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {number[]}\n * @return {any}\n */\nvar maxCoins = function(nums) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object maxCoins(int[] nums) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int maxCoins(vector<int>& nums) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
{"functionName": "merge", "evalMode": "exactMatch", "inputParameters": {"python": ["intervals", "List[List[int]]"], "javascript": ["intervals", "number[][]"], "cpp": ["intervals", "vector<vector<int>>&"], "java": ["intervals", "int[][]"]}, "tests": [{"input": {"intervals": [[1, 3], [2, 6], [8, 10], [15, 18]]}, "output": [[1, 6], [8, 10], [15, 18]]}, {"input": {"intervals": [[1, 4], [4, 5]]}, "output": [[1, 5]]}], "title": "Merge Intervals", "question": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\nConstraints:\n\n1 <= intervals.length <= 104\nintervals[i].length == 2\n0 <= starti <= endi <= 104", "difficulty": 2, "category": ["Array", "Sorting"], "solutions": {"sorting": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda pair: pair[0])\n        output = [intervals[0]]\n        \n        for start, end in intervals:\n            lastEnd = output[-1][1]\n            \n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output"}, "startingCode": {"python": "from typing import List, Optional\n\nclass Solution:\n    def merge(self, intervals: List[List[int]]):\n        # TODO: Write your Python code here\n        pass", "javascript": "/**\n * @param {number[][]}\n * @return {any}\n */\nvar merge = function(intervals) {\n    // TODO: Write your JavaScript code here\n};", "java": "class Solution {\n    public Object merge(int[][] intervals) {\n        // TODO: Write your Java code here\n        return null;\n    }\n}", "cpp": "class Solution {\npublic:\n    int merge(vector<vector<int>>& intervals) {\n        // TODO: Write your C++ code here\n        return 0;\n    }\n};"}}
