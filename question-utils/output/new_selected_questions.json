[
  {
    "category": [
      "Math",
      "String"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>For two strings <code>s</code> and <code>t</code>, we say &quot;<code>t</code> divides <code>s</code>&quot; if and only if <code>s = t + t + t + ... + t + t</code> (i.e., <code>t</code> is concatenated with itself one or more times).</p>\n\n<p>Given two strings <code>str1</code> and <code>str2</code>, return <em>the largest string </em><code>x</code><em> such that </em><code>x</code><em> divides both </em><code>str1</code><em> and </em><code>str2</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;\n<strong>Output:</strong> &quot;ABC&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;\n<strong>Output:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;\n<strong>Output:</strong> &quot;&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>\n\t<li><code>str1</code> and <code>str2</code> consist of English uppercase letters.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "findLargestCommonDivisorString",
    "inputParameters": {
      "cpp": {
        "str1": "string",
        "str2": "string"
      },
      "java": {
        "str1": "String",
        "str2": "String"
      },
      "javascript": {
        "str1": "string",
        "str2": "string"
      },
      "python": {
        "str1": "str",
        "str2": "str"
      }
    },
    "tests": [
      {
        "input": {
          "str1": "ABCABC",
          "str2": "ABC"
        },
        "output": "ABC"
      },
      {
        "input": {
          "str1": "ABABAB",
          "str2": "ABAB"
        },
        "output": "AB"
      },
      {
        "input": {
          "str1": "LEET",
          "str2": "CODE"
        },
        "output": ""
      },
      {
        "input": {
          "str1": "TAUXXTAUXXTAUXXTAUXXTAUXX",
          "str2": "TAUXXTAUXXTAUXXTAUXX"
        },
        "output": "TAUXX"
      },
      {
        "input": {
          "str1": "ABCDEF",
          "str2": "ABC"
        },
        "output": ""
      },
      {
        "input": {
          "str1": "AAAAAAAAA",
          "str2": "AAACCC"
        },
        "output": ""
      },
      {
        "input": {
          "str1": "ABABABAB",
          "str2": "ABAB"
        },
        "output": "ABAB"
      },
      {
        "input": {
          "str1": "X",
          "str2": "X"
        },
        "output": "X"
      },
      {
        "input": {
          "str1": "XXXX",
          "str2": "XX"
        },
        "output": "XX"
      },
      {
        "input": {
          "str1": "AAAAABBBBB",
          "str2": "ABABABAB"
        },
        "output": ""
      }
    ],
    "title": "Greatest Common Divisor of Strings",
    "metaData": {},
    "outputParameters": "string"
  },
  {
    "category": [
      "Array"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>There are <code>n</code> kids with candies. You are given an integer array <code>candies</code>, where each <code>candies[i]</code> represents the number of candies the <code>i<sup>th</sup></code> kid has, and an integer <code>extraCandies</code>, denoting the number of extra candies that you have.</p>\n\n<p>Return <em>a boolean array </em><code>result</code><em> of length </em><code>n</code><em>, where </em><code>result[i]</code><em> is </em><code>true</code><em> if, after giving the </em><code>i<sup>th</sup></code><em> kid all the </em><code>extraCandies</code><em>, they will have the <strong>greatest</strong> number of candies among all the kids</em><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>Note that <strong>multiple</strong> kids can have the <strong>greatest</strong> number of candies.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candies = [2,3,5,1,3], extraCandies = 3\n<strong>Output:</strong> [true,true,true,false,true] \n<strong>Explanation:</strong> If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candies = [4,2,1,1,2], extraCandies = 1\n<strong>Output:</strong> [true,false,false,false,false] \n<strong>Explanation:</strong> There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candies = [12,1,12], extraCandies = 10\n<strong>Output:</strong> [true,false,true]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == candies.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "kidsWithCandiesGreatestAfterExtra",
    "inputParameters": {
      "cpp": {
        "candies": "vector<int>",
        "extraCandies": "int"
      },
      "java": {
        "candies": "int[]",
        "extraCandies": "int"
      },
      "javascript": {
        "candies": "number[]",
        "extraCandies": "number"
      },
      "python": {
        "candies": "List[int]",
        "extraCandies": "int"
      }
    },
    "tests": [
      {
        "input": {
          "candies": [
            2,
            3,
            5,
            1,
            3
          ],
          "extraCandies": 3
        },
        "output": [
          true,
          true,
          true,
          false,
          true
        ]
      },
      {
        "input": {
          "candies": [
            4,
            2,
            1,
            1,
            2
          ],
          "extraCandies": 1
        },
        "output": [
          true,
          false,
          false,
          false,
          false
        ]
      },
      {
        "input": {
          "candies": [
            12,
            1,
            12
          ],
          "extraCandies": 10
        },
        "output": [
          true,
          false,
          true
        ]
      },
      {
        "input": {
          "candies": [
            1,
            1,
            1,
            1
          ],
          "extraCandies": 1
        },
        "output": [
          true,
          true,
          true,
          true
        ]
      },
      {
        "input": {
          "candies": [
            1,
            2,
            3,
            4,
            5
          ],
          "extraCandies": 5
        },
        "output": [
          true,
          true,
          true,
          true,
          true
        ]
      },
      {
        "input": {
          "candies": [
            10,
            1
          ],
          "extraCandies": 8
        },
        "output": [
          true,
          false
        ]
      },
      {
        "input": {
          "candies": [
            1,
            1,
            1,
            1,
            1
          ],
          "extraCandies": 0
        },
        "output": [
          true,
          true,
          true,
          true,
          true
        ]
      },
      {
        "input": {
          "candies": [
            100
          ],
          "extraCandies": 50
        },
        "output": [
          true
        ]
      },
      {
        "input": {
          "candies": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ],
          "extraCandies": 1
        },
        "output": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          true
        ]
      },
      {
        "input": {
          "candies": [
            5,
            5,
            5,
            5,
            5
          ],
          "extraCandies": 2
        },
        "output": [
          true,
          true,
          true,
          true,
          true
        ]
      }
    ],
    "title": "Kids With the Greatest Number of Candies",
    "metaData": {},
    "outputParameters": "List[boolean]"
  },
  {
    "category": [
      "Array",
      "Greedy"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in <strong>adjacent</strong> plots.</p>\n\n<p>Given an integer array <code>flowerbed</code> containing <code>0</code>&#39;s and <code>1</code>&#39;s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return <code>true</code>&nbsp;<em>if</em> <code>n</code> <em>new flowers can be planted in the</em> <code>flowerbed</code> <em>without violating the no-adjacent-flowers rule and</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> flowerbed = [1,0,0,0,1], n = 1\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> flowerbed = [1,0,0,0,1], n = 2\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>flowerbed[i]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li>There are no two adjacent flowers in <code>flowerbed</code>.</li>\n\t<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "canPlaceFlowers",
    "inputParameters": {
      "cpp": {
        "flowerbed": "vector<int>",
        "n": "int"
      },
      "java": {
        "flowerbed": "int[]",
        "n": "int"
      },
      "javascript": {
        "flowerbed": "number[]",
        "n": "number"
      },
      "python": {
        "flowerbed": "List[int]",
        "n": "int"
      }
    },
    "tests": [
      {
        "input": {
          "flowerbed": [
            1,
            0,
            0,
            0,
            1
          ],
          "n": 1
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            1,
            0,
            0,
            0,
            1
          ],
          "n": 2
        },
        "output": false
      },
      {
        "input": {
          "flowerbed": [
            0,
            0,
            0,
            0,
            0
          ],
          "n": 3
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            1,
            0,
            0,
            0,
            0,
            0,
            1
          ],
          "n": 2
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            0
          ],
          "n": 1
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            1
          ],
          "n": 0
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            0,
            0,
            1,
            0,
            1
          ],
          "n": 1
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            1,
            0,
            1,
            0,
            1,
            0,
            1
          ],
          "n": 0
        },
        "output": true
      },
      {
        "input": {
          "flowerbed": [
            0,
            0,
            0,
            0
          ],
          "n": 3
        },
        "output": false
      },
      {
        "input": {
          "flowerbed": [
            1,
            0,
            0,
            0,
            1,
            0,
            0
          ],
          "n": 2
        },
        "output": true
      }
    ],
    "title": "Can Place Flowers",
    "metaData": {},
    "outputParameters": "boolean"
  },
  {
    "category": [
      "Two Pointers",
      "String"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n",
    "solutions": {},
    "functionName": "reverseWordsInString",
    "inputParameters": {
      "cpp": {
        "s": "string"
      },
      "java": {
        "s": "String"
      },
      "javascript": {
        "s": "string"
      },
      "python": {
        "s": "str"
      }
    },
    "tests": [
      {
        "input": {
          "s": "the sky is blue"
        },
        "output": "blue is sky the"
      },
      {
        "input": {
          "s": "  hello world  "
        },
        "output": "world hello"
      },
      {
        "input": {
          "s": "a good   example"
        },
        "output": "example good a"
      },
      {
        "input": {
          "s": "  Bob    Loves  Alice   "
        },
        "output": "Alice Loves Bob"
      },
      {
        "input": {
          "s": "Alice does not     even like bob"
        },
        "output": "bob like even not does Alice"
      },
      {
        "input": {
          "s": "Reverse these words"
        },
        "output": "words these Reverse"
      },
      {
        "input": {
          "s": "   "
        },
        "output": ""
      },
      {
        "input": {
          "s": "a"
        },
        "output": "a"
      },
      {
        "input": {
          "s": "  42  "
        },
        "output": "42"
      },
      {
        "input": {
          "s": "I love programming very much"
        },
        "output": "much very programming love I"
      }
    ],
    "title": "Reverse Words in a String",
    "metaData": {},
    "outputParameters": "string"
  },
  {
    "category": [
      "Array",
      "Prefix Sum"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>\n\n<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [24,12,8,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]\n<strong>Output:</strong> [0,0,9,0,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>\n",
    "solutions": {},
    "functionName": "productExceptSelf",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>"
      },
      "java": {
        "nums": "int[]"
      },
      "javascript": {
        "nums": "number[]"
      },
      "python": {
        "nums": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4
          ]
        },
        "output": [
          24,
          12,
          8,
          6
        ]
      },
      {
        "input": {
          "nums": [
            -1,
            1,
            0,
            -3,
            3
          ]
        },
        "output": [
          0,
          0,
          9,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1
          ]
        },
        "output": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "input": {
          "nums": [
            2,
            3,
            4,
            5,
            6
          ]
        },
        "output": [
          360,
          240,
          180,
          144,
          120
        ]
      },
      {
        "input": {
          "nums": [
            -2,
            -3,
            -4,
            -5
          ]
        },
        "output": [
          -60,
          -40,
          -30,
          -24
        ]
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0,
            0,
            0
          ]
        },
        "output": [
          0,
          0,
          0,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            1,
            0,
            1,
            0,
            1
          ]
        },
        "output": [
          0,
          1,
          0,
          1,
          0
        ]
      },
      {
        "input": {
          "nums": [
            10,
            5
          ]
        },
        "output": [
          5,
          10
        ]
      },
      {
        "input": {
          "nums": [
            -1,
            -1,
            0,
            1,
            1
          ]
        },
        "output": [
          0,
          0,
          1,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ]
        },
        "output": [
          3628800,
          1814400,
          1209600,
          907200,
          725760,
          604800,
          518400,
          453600,
          403200,
          362880
        ]
      }
    ],
    "title": "Product of Array Except Self",
    "metaData": {},
    "outputParameters": "List[integer]"
  },
  {
    "category": [
      "Array",
      "Greedy"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given an integer array <code>nums</code>, return <code>true</code><em> if there exists a triple of indices </em><code>(i, j, k)</code><em> such that </em><code>i &lt; j &lt; k</code><em> and </em><code>nums[i] &lt; nums[j] &lt; nums[k]</code>. If no such indices exists, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Any triplet where i &lt; j &lt; k is valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,3,2,1]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> No triplet exists.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,5,0,4,6]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The triplet (3, 4, 5) is valid because nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you implement a solution that runs in <code>O(n)</code> time complexity and <code>O(1)</code> space complexity?",
    "solutions": {},
    "functionName": "hasIncreasingTriplet",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>"
      },
      "java": {
        "nums": "int[]"
      },
      "javascript": {
        "nums": "number[]"
      },
      "python": {
        "nums": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "output": true
      },
      {
        "input": {
          "nums": [
            5,
            4,
            3,
            2,
            1
          ]
        },
        "output": false
      },
      {
        "input": {
          "nums": [
            2,
            1,
            5,
            0,
            4,
            6
          ]
        },
        "output": true
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1,
            1,
            1
          ]
        },
        "output": false
      },
      {
        "input": {
          "nums": [
            1,
            5,
            0,
            4,
            1,
            3
          ]
        },
        "output": true
      },
      {
        "input": {
          "nums": [
            20,
            100,
            10,
            12,
            5,
            13
          ]
        },
        "output": true
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ]
        },
        "output": true
      },
      {
        "input": {
          "nums": [
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ]
        },
        "output": false
      },
      {
        "input": {
          "nums": [
            1,
            4,
            0,
            1,
            2,
            3
          ]
        },
        "output": true
      },
      {
        "input": {
          "nums": [
            1
          ]
        },
        "output": false
      }
    ],
    "title": "Increasing Triplet Subsequence",
    "metaData": {},
    "outputParameters": "boolean"
  },
  {
    "category": [
      "Two Pointers",
      "String"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given an array of characters <code>chars</code>, compress it using the following algorithm:</p>\n\n<p>Begin with an empty string <code>s</code>. For each group of <strong>consecutive repeating characters</strong> in <code>chars</code>:</p>\n\n<ul>\n\t<li>If the group&#39;s length is <code>1</code>, append the character to <code>s</code>.</li>\n\t<li>Otherwise, append the character followed by the group&#39;s length.</li>\n</ul>\n\n<p>The compressed string <code>s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code>chars</code></strong>. Note that group lengths that are <code>10</code> or longer will be split into multiple characters in <code>chars</code>.</p>\n\n<p>After you are done <strong>modifying the input array,</strong> return <em>the new length of the array</em>.</p>\n\n<p>You must write an algorithm that uses only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]\n<strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]\n<strong>Explanation:</strong> The groups are &quot;aa&quot;, &quot;bb&quot;, and &quot;ccc&quot;. This compresses to &quot;a2b2c3&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> chars = [&quot;a&quot;]\n<strong>Output:</strong> Return 1, and the first character of the input array should be: [&quot;a&quot;]\n<strong>Explanation:</strong> The only group is &quot;a&quot;, which remains uncompressed since it&#39;s a single character.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]\n<strong>Output:</strong> Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].\n<strong>Explanation:</strong> The groups are &quot;a&quot; and &quot;bbbbbbbbbbbb&quot;. This compresses to &quot;ab12&quot;.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= chars.length &lt;= 2000</code></li>\n\t<li><code>chars[i]</code> is a lowercase English letter, uppercase English letter, digit, or symbol.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "compressCharArray",
    "inputParameters": {
      "cpp": {
        "chars": "vector<char>&"
      },
      "java": {
        "chars": "char[]"
      },
      "javascript": {
        "chars": "character[]"
      },
      "python": {
        "chars": "List[str]"
      }
    },
    "tests": [
      {
        "input": {
          "chars": [
            "a",
            "a",
            "b",
            "b",
            "c",
            "c",
            "c"
          ]
        },
        "output": 6
      },
      {
        "input": {
          "chars": [
            "a"
          ]
        },
        "output": 1
      },
      {
        "input": {
          "chars": [
            "a",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b"
          ]
        },
        "output": 4
      },
      {
        "input": {
          "chars": [
            "a",
            "a",
            "a",
            "b",
            "b",
            "a",
            "a"
          ]
        },
        "output": 6
      },
      {
        "input": {
          "chars": [
            "a",
            "b",
            "c",
            "d",
            "e"
          ]
        },
        "output": 5
      },
      {
        "input": {
          "chars": [
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "a"
          ]
        },
        "output": 3
      },
      {
        "input": {
          "chars": [
            "a",
            "b",
            "b",
            "c",
            "c",
            "c"
          ]
        },
        "output": 5
      },
      {
        "input": {
          "chars": [
            "a",
            "2",
            "b",
            "2",
            "c",
            "3"
          ]
        },
        "output": 6
      },
      {
        "input": {
          "chars": [
            "a",
            "a",
            "a",
            "a",
            "a",
            "a",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "b",
            "c",
            "c",
            "c",
            "c",
            "c",
            "c",
            "c",
            "c",
            "c",
            "c"
          ]
        },
        "output": 8
      },
      {
        "input": {
          "chars": [
            "#",
            "#",
            "*",
            "*",
            "*",
            "*",
            "*",
            "*",
            "*",
            "*",
            "*",
            "*"
          ]
        },
        "output": 5
      }
    ],
    "title": "String Compression",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Two Pointers"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>Given an integer array <code>nums</code>, move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>\n\n<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,3,12]\n<strong>Output:</strong> [1,3,12,0,0]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you minimize the total number of operations done?",
    "solutions": {},
    "functionName": "moveZeroesToEnd",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>&"
      },
      "java": {
        "nums": "int[]"
      },
      "javascript": {
        "nums": "number[]"
      },
      "python": {
        "nums": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            0,
            1,
            0,
            3,
            12
          ]
        },
        "output": [
          1,
          3,
          12,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            0
          ]
        },
        "output": [
          0
        ]
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "output": [
          1,
          2,
          3,
          4,
          5
        ]
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0,
            0,
            1
          ]
        },
        "output": [
          1,
          0,
          0,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            1,
            0,
            0,
            0,
            0
          ]
        },
        "output": [
          1,
          0,
          0,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            1,
            2,
            0,
            3,
            0,
            4,
            0,
            5
          ]
        },
        "output": [
          1,
          2,
          3,
          4,
          5,
          0,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            -1,
            0,
            2,
            -3,
            0,
            4,
            0,
            -5
          ]
        },
        "output": [
          -1,
          2,
          -3,
          4,
          -5,
          0,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0
          ]
        },
        "output": [
          0,
          0,
          0
        ]
      },
      {
        "input": {
          "nums": [
            1
          ]
        },
        "output": [
          1
        ]
      },
      {
        "input": {
          "nums": [
            9,
            0,
            9,
            0,
            9,
            0
          ]
        },
        "output": [
          9,
          9,
          9,
          0,
          0,
          0
        ]
      }
    ],
    "title": "Move Zeroes",
    "metaData": {},
    "outputParameters": "List[integer]"
  },
  {
    "category": [
      "Two Pointers",
      "String",
      "Dynamic Programming"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>subsequence</strong> of </em><code>t</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abc\", t = \"ahbgdc\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"axc\", t = \"ahbgdc\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Suppose there are lots of incoming <code>s</code>, say <code>s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub></code> where <code>k &gt;= 10<sup>9</sup></code>, and you want to check one by one to see if <code>t</code> has its subsequence. In this scenario, how would you change your code?",
    "solutions": {},
    "functionName": "isSubsequence",
    "inputParameters": {
      "cpp": {
        "s": "string",
        "t": "string"
      },
      "java": {
        "s": "String",
        "t": "String"
      },
      "javascript": {
        "s": "string",
        "t": "string"
      },
      "python": {
        "s": "str",
        "t": "str"
      }
    },
    "tests": [
      {
        "input": {
          "s": "abc",
          "t": "ahbgdc"
        },
        "output": true
      },
      {
        "input": {
          "s": "axc",
          "t": "ahbgdc"
        },
        "output": false
      },
      {
        "input": {
          "s": "",
          "t": "ahbgdc"
        },
        "output": true
      },
      {
        "input": {
          "s": "abc",
          "t": ""
        },
        "output": false
      },
      {
        "input": {
          "s": "abc",
          "t": "abc"
        },
        "output": true
      },
      {
        "input": {
          "s": "abcde",
          "t": "ace"
        },
        "output": false
      },
      {
        "input": {
          "s": "aaaaaa",
          "t": "bbaaaa"
        },
        "output": false
      },
      {
        "input": {
          "s": "leetcode",
          "t": "yleetcode"
        },
        "output": true
      },
      {
        "input": {
          "s": "b",
          "t": "abc"
        },
        "output": true
      },
      {
        "input": {
          "s": "aec",
          "t": "abcde"
        },
        "output": false
      }
    ],
    "title": "Is Subsequence",
    "metaData": {},
    "outputParameters": "boolean"
  },
  {
    "category": [
      "Array",
      "Two Pointers",
      "Greedy"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>\n\n<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>\n\n<p>Return <em>the maximum amount of water a container can store</em>.</p>\n\n<p><strong>Notice</strong> that you may not slant the container.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" style=\"width: 600px; height: 287px;\" />\n<pre>\n<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]\n<strong>Output:</strong> 49\n<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [1,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "maxAreaContainer",
    "inputParameters": {
      "cpp": {
        "height": "vector<int>"
      },
      "java": {
        "height": "int[]"
      },
      "javascript": {
        "height": "number[]"
      },
      "python": {
        "height": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "height": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ]
        },
        "output": 49
      },
      {
        "input": {
          "height": [
            1,
            1
          ]
        },
        "output": 1
      },
      {
        "input": {
          "height": [
            4,
            3,
            2,
            1,
            4
          ]
        },
        "output": 16
      },
      {
        "input": {
          "height": [
            1,
            2,
            1
          ]
        },
        "output": 2
      },
      {
        "input": {
          "height": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            25,
            7
          ]
        },
        "output": 49
      },
      {
        "input": {
          "height": [
            2,
            3,
            4,
            5,
            18,
            17,
            6
          ]
        },
        "output": 17
      },
      {
        "input": {
          "height": [
            1,
            3,
            2,
            5,
            25,
            24,
            5
          ]
        },
        "output": 24
      },
      {
        "input": {
          "height": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ]
        },
        "output": 7
      },
      {
        "input": {
          "height": [
            10000,
            1,
            1,
            1,
            1,
            1,
            1,
            10000
          ]
        },
        "output": 70000
      },
      {
        "input": {
          "height": [
            2,
            3,
            10,
            5,
            7,
            8,
            9,
            1
          ]
        },
        "output": 36
      }
    ],
    "title": "Container With Most Water",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Hash Table",
      "Two Pointers",
      "Sorting"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>\n\n<p>In one operation, you can pick two numbers from the array whose sum equals <code>k</code> and remove them from the array.</p>\n\n<p>Return <em>the maximum number of operations you can perform on the array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,3], k = 6\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3&#39;s, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "maxKSumPairs",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>",
        "k": "int"
      },
      "java": {
        "nums": "int[]",
        "k": "int"
      },
      "javascript": {
        "nums": "number[]",
        "k": "number"
      },
      "python": {
        "nums": "List[int]",
        "k": "int"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4
          ],
          "k": 5
        },
        "output": 2
      },
      {
        "input": {
          "nums": [
            3,
            1,
            3,
            4,
            3
          ],
          "k": 6
        },
        "output": 1
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1
          ],
          "k": 2
        },
        "output": 2
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "k": 7
        },
        "output": 3
      },
      {
        "input": {
          "nums": [
            1,
            1,
            2,
            2,
            3,
            3
          ],
          "k": 4
        },
        "output": 3
      },
      {
        "input": {
          "nums": [
            10,
            10,
            10,
            10,
            10
          ],
          "k": 20
        },
        "output": 2
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5
          ],
          "k": 10
        },
        "output": 0
      },
      {
        "input": {
          "nums": [
            1
          ],
          "k": 1
        },
        "output": 0
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ],
          "k": 11
        },
        "output": 5
      },
      {
        "input": {
          "nums": [
            1000000000,
            1000000000
          ],
          "k": 2000000000
        },
        "output": 1
      }
    ],
    "title": "Max Number of K-Sum Pairs",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Sliding Window"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>You are given an integer array <code>nums</code> consisting of <code>n</code> elements, and an integer <code>k</code>.</p>\n\n<p>Find a contiguous subarray whose <strong>length is equal to</strong> <code>k</code> that has the maximum average value and return <em>this value</em>. Any answer with a calculation error less than <code>10<sup>-5</sup></code> will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,12,-5,-6,50,3], k = 4\n<strong>Output:</strong> 12.75000\n<strong>Explanation:</strong> Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5], k = 1\n<strong>Output:</strong> 5.00000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "findMaxAverageSubarray",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>",
        "k": "int"
      },
      "java": {
        "nums": "int[]",
        "k": "int"
      },
      "javascript": {
        "nums": "number[]",
        "k": "number"
      },
      "python": {
        "nums": "List[int]",
        "k": "int"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            1,
            12,
            -5,
            -6,
            50,
            3
          ],
          "k": 4
        },
        "output": 12.75
      },
      {
        "input": {
          "nums": [
            5
          ],
          "k": 1
        },
        "output": 5.0
      },
      {
        "input": {
          "nums": [
            -1,
            -2,
            -3,
            -4,
            -5
          ],
          "k": 3
        },
        "output": -2.0
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5
          ],
          "k": 2
        },
        "output": 4.5
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0,
            0,
            0
          ],
          "k": 5
        },
        "output": 0.0
      },
      {
        "input": {
          "nums": [
            10000,
            -10000,
            10000,
            -10000
          ],
          "k": 2
        },
        "output": 0.0
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          "k": 10
        },
        "output": 1.0
      },
      {
        "input": {
          "nums": [
            -1,
            1,
            -1,
            1,
            -1,
            1,
            -1,
            1
          ],
          "k": 3
        },
        "output": 0.33333
      },
      {
        "input": {
          "nums": [
            9999,
            9999,
            9999,
            9999
          ],
          "k": 4
        },
        "output": 9999.0
      },
      {
        "input": {
          "nums": [
            -5,
            -4,
            -3,
            -2,
            -1,
            0,
            1,
            2,
            3,
            4,
            5
          ],
          "k": 5
        },
        "output": 3.0
      }
    ],
    "title": "Maximum Average Subarray I",
    "metaData": {},
    "outputParameters": "float"
  },
  {
    "category": [
      "String",
      "Sliding Window"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given a string <code>s</code> and an integer <code>k</code>, return <em>the maximum number of vowel letters in any substring of </em><code>s</code><em> with length </em><code>k</code>.</p>\n\n<p><strong>Vowel letters</strong> in English are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abciiidef&quot;, k = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The substring &quot;iii&quot; contains 3 vowel letters.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aeiou&quot;, k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Any substring of length 2 contains 2 vowels.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, k = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "maxVowelsInSubstring",
    "inputParameters": {
      "cpp": {
        "s": "string",
        "k": "int"
      },
      "java": {
        "s": "String",
        "k": "int"
      },
      "javascript": {
        "s": "string",
        "k": "number"
      },
      "python": {
        "s": "str",
        "k": "int"
      }
    },
    "tests": [
      {
        "input": {
          "s": "abciiidef",
          "k": 3
        },
        "output": 3
      },
      {
        "input": {
          "s": "aeiou",
          "k": 2
        },
        "output": 2
      },
      {
        "input": {
          "s": "leetcode",
          "k": 3
        },
        "output": 2
      },
      {
        "input": {
          "s": "rhythms",
          "k": 4
        },
        "output": 0
      },
      {
        "input": {
          "s": "aaaaaa",
          "k": 2
        },
        "output": 2
      },
      {
        "input": {
          "s": "ibpbhixfiouhdljnjfflpapptrxgcomvnb",
          "k": 7
        },
        "output": 3
      },
      {
        "input": {
          "s": "qwrtypsdfghjklzxcvbnm",
          "k": 5
        },
        "output": 0
      },
      {
        "input": {
          "s": "aeioubcdfg",
          "k": 5
        },
        "output": 5
      },
      {
        "input": {
          "s": "abcdefghijklmnopqrstuvwxyz",
          "k": 26
        },
        "output": 5
      },
      {
        "input": {
          "s": "a",
          "k": 1
        },
        "output": 1
      }
    ],
    "title": "Maximum Number of Vowels in a Substring of Given Length",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Binary Search",
      "Sliding Window",
      "Prefix Sum"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given a binary array <code>nums</code> and an integer <code>k</code>, return <em>the maximum number of consecutive </em><code>1</code><em>&#39;s in the array if you can flip at most</em> <code>k</code> <code>0</code>&#39;s.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [1,1,1,0,0,<u><strong>1</strong>,1,1,1,1,<strong>1</strong></u>]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> [0,0,<u>1,1,<strong>1</strong>,<strong>1</strong>,1,1,1,<strong>1</strong>,1,1</u>,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "longestConsecutiveOnesWithFlips",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>",
        "k": "int"
      },
      "java": {
        "nums": "int[]",
        "k": "int"
      },
      "javascript": {
        "nums": "number[]",
        "k": "number"
      },
      "python": {
        "nums": "List[int]",
        "k": "int"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0
          ],
          "k": 2
        },
        "output": 6
      },
      {
        "input": {
          "nums": [
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            1,
            1,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1
          ],
          "k": 3
        },
        "output": 10
      },
      {
        "input": {
          "nums": [
            1,
            1,
            1,
            1,
            1
          ],
          "k": 0
        },
        "output": 5
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0,
            0
          ],
          "k": 0
        },
        "output": 0
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0,
            0
          ],
          "k": 4
        },
        "output": 4
      },
      {
        "input": {
          "nums": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
          ],
          "k": 1
        },
        "output": 3
      },
      {
        "input": {
          "nums": [
            1,
            0,
            1,
            0,
            1,
            0,
            1,
            0
          ],
          "k": 2
        },
        "output": 5
      },
      {
        "input": {
          "nums": [
            0,
            1,
            0,
            1,
            0,
            1,
            0,
            1
          ],
          "k": 3
        },
        "output": 8
      },
      {
        "input": {
          "nums": [
            1
          ],
          "k": 0
        },
        "output": 1
      },
      {
        "input": {
          "nums": [
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            0,
            1,
            0
          ],
          "k": 3
        },
        "output": 9
      }
    ],
    "title": "Max Consecutive Ones III",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Prefix Sum"
    ],
    "difficulty": 1,
    "evalMode": "exactMatch",
    "question": "<p>There is a biker going on a road trip. The road trip consists of <code>n + 1</code> points at different altitudes. The biker starts his trip on point <code>0</code> with altitude equal <code>0</code>.</p>\n\n<p>You are given an integer array <code>gain</code> of length <code>n</code> where <code>gain[i]</code> is the <strong>net gain in altitude</strong> between points <code>i</code>\u200b\u200b\u200b\u200b\u200b\u200b and <code>i + 1</code> for all (<code>0 &lt;= i &lt; n)</code>. Return <em>the <strong>highest altitude</strong> of a point.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> gain = [-5,1,5,0,-7]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> gain = [-4,-3,-2,-1,4,3,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == gain.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= gain[i] &lt;= 100</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "findHighestAltitude",
    "inputParameters": {
      "cpp": {
        "gain": "vector<int>"
      },
      "java": {
        "gain": "int[]"
      },
      "javascript": {
        "gain": "number[]"
      },
      "python": {
        "gain": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "gain": [
            -5,
            1,
            5,
            0,
            -7
          ]
        },
        "output": 1
      },
      {
        "input": {
          "gain": [
            -4,
            -3,
            -2,
            -1,
            4,
            3,
            2
          ]
        },
        "output": 0
      },
      {
        "input": {
          "gain": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "output": 15
      },
      {
        "input": {
          "gain": [
            -1,
            -2,
            -3,
            -4,
            -5
          ]
        },
        "output": 0
      },
      {
        "input": {
          "gain": [
            10,
            -10,
            10,
            -10
          ]
        },
        "output": 10
      },
      {
        "input": {
          "gain": [
            0,
            0,
            0,
            0,
            0
          ]
        },
        "output": 0
      },
      {
        "input": {
          "gain": [
            100
          ]
        },
        "output": 100
      },
      {
        "input": {
          "gain": [
            -100
          ]
        },
        "output": 0
      },
      {
        "input": {
          "gain": [
            1,
            -1,
            1,
            -1,
            1,
            -1
          ]
        },
        "output": 1
      },
      {
        "input": {
          "gain": [
            -50,
            50,
            -50,
            50,
            -50,
            50
          ]
        },
        "output": 50
      }
    ],
    "title": "Find the Highest Altitude",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Hash Table",
      "Matrix",
      "Simulation"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given a <strong>0-indexed</strong> <code>n x n</code> integer matrix <code>grid</code>, <em>return the number of pairs </em><code>(r<sub>i</sub>, c<sub>j</sub>)</code><em> such that row </em><code>r<sub>i</sub></code><em> and column </em><code>c<sub>j</sub></code><em> are equal</em>.</p>\n\n<p>A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg\" style=\"width: 150px; height: 153px;\" />\n<pre>\n<strong>Input:</strong> grid = [[3,2,1],[1,7,6],[2,7,7]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There is 1 equal row and column pair:\n- (Row 2, Column 1): [2,7,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg\" style=\"width: 200px; height: 209px;\" />\n<pre>\n<strong>Input:</strong> grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "countEqualRowColumnPairs",
    "inputParameters": {
      "cpp": {
        "grid": "vector<vector<int>>"
      },
      "java": {
        "grid": "int[][]"
      },
      "javascript": {
        "grid": "number[][]"
      },
      "python": {
        "grid": "List[List[int]]"
      }
    },
    "tests": [
      {
        "input": {
          "grid": [
            [
              3,
              2,
              1
            ],
            [
              1,
              7,
              6
            ],
            [
              2,
              7,
              7
            ]
          ]
        },
        "output": 1
      },
      {
        "input": {
          "grid": [
            [
              3,
              1,
              2,
              2
            ],
            [
              1,
              4,
              4,
              5
            ],
            [
              2,
              4,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2
            ]
          ]
        },
        "output": 3
      },
      {
        "input": {
          "grid": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ]
        },
        "output": 4
      },
      {
        "input": {
          "grid": [
            [
              1
            ]
          ]
        },
        "output": 1
      },
      {
        "input": {
          "grid": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "grid": [
            [
              1,
              2
            ],
            [
              2,
              1
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "grid": [
            [
              1,
              2,
              3
            ],
            [
              1,
              2,
              3
            ],
            [
              1,
              2,
              3
            ]
          ]
        },
        "output": 3
      },
      {
        "input": {
          "grid": [
            [
              1,
              2,
              3,
              4
            ],
            [
              5,
              6,
              7,
              8
            ],
            [
              9,
              10,
              11,
              12
            ],
            [
              13,
              14,
              15,
              16
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "grid": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ]
        },
        "output": 9
      },
      {
        "input": {
          "grid": [
            [
              100000,
              1
            ],
            [
              1,
              100000
            ]
          ]
        },
        "output": 0
      }
    ],
    "title": "Equal Row and Column Pairs",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "String",
      "Stack",
      "Simulation"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>You are given a string <code>s</code>, which contains stars <code>*</code>.</p>\n\n<p>In one operation, you can:</p>\n\n<ul>\n\t<li>Choose a star in <code>s</code>.</li>\n\t<li>Remove the closest <strong>non-star</strong> character to its <strong>left</strong>, as well as remove the star itself.</li>\n</ul>\n\n<p>Return <em>the string after <strong>all</strong> stars have been removed</em>.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>The input will be generated such that the operation is always possible.</li>\n\t<li>It can be shown that the resulting string will always be unique.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leet**cod*e&quot;\n<strong>Output:</strong> &quot;lecoe&quot;\n<strong>Explanation:</strong> Performing the removals from left to right:\n- The closest character to the 1<sup>st</sup> star is &#39;t&#39; in &quot;lee<strong><u>t</u></strong>**cod*e&quot;. s becomes &quot;lee*cod*e&quot;.\n- The closest character to the 2<sup>nd</sup> star is &#39;e&#39; in &quot;le<strong><u>e</u></strong>*cod*e&quot;. s becomes &quot;lecod*e&quot;.\n- The closest character to the 3<sup>rd</sup> star is &#39;d&#39; in &quot;leco<strong><u>d</u></strong>*e&quot;. s becomes &quot;lecoe&quot;.\nThere are no more stars, so we return &quot;lecoe&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;erase*****&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> The entire string is removed, so we return an empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters and stars <code>*</code>.</li>\n\t<li>The operation above can be performed on <code>s</code>.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "removeStarsFromString",
    "inputParameters": {
      "cpp": {
        "s": "string"
      },
      "java": {
        "s": "String"
      },
      "javascript": {
        "s": "string"
      },
      "python": {
        "s": "str"
      }
    },
    "tests": [
      {
        "input": {
          "s": "leet**cod*e"
        },
        "output": "lecoe"
      },
      {
        "input": {
          "s": "erase*****"
        },
        "output": ""
      },
      {
        "input": {
          "s": "a*b*c*"
        },
        "output": ""
      },
      {
        "input": {
          "s": "abc*def*ghi"
        },
        "output": "abdefghi"
      },
      {
        "input": {
          "s": "abc**def**ghi"
        },
        "output": "aghi"
      },
      {
        "input": {
          "s": "*****"
        },
        "output": ""
      },
      {
        "input": {
          "s": "abcde"
        },
        "output": "abcde"
      },
      {
        "input": {
          "s": "a*a*a*a*"
        },
        "output": ""
      },
      {
        "input": {
          "s": "abb*ccc**d*"
        },
        "output": "abcd"
      },
      {
        "input": {
          "s": "leetcode*"
        },
        "output": "leetcod"
      }
    ],
    "title": "Removing Stars From a String",
    "metaData": {},
    "outputParameters": "string"
  },
  {
    "category": [
      "Array",
      "Stack",
      "Simulation"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>We are given an array <code>asteroids</code> of integers representing asteroids in a row.</p>\n\n<p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p>\n\n<p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> asteroids = [5,10,-5]\n<strong>Output:</strong> [5,10]\n<strong>Explanation:</strong> The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> asteroids = [8,-8]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The 8 and -8 collide exploding each other.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> asteroids = [10,2,-5]\n<strong>Output:</strong> [10]\n<strong>Explanation:</strong> The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= asteroids.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>\n\t<li><code>asteroids[i] != 0</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "simulateAsteroidCollisions",
    "inputParameters": {
      "cpp": {
        "asteroids": "vector<int>"
      },
      "java": {
        "asteroids": "int[]"
      },
      "javascript": {
        "asteroids": "number[]"
      },
      "python": {
        "asteroids": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "asteroids": [
            5,
            10,
            -5
          ]
        },
        "output": [
          5,
          10
        ]
      },
      {
        "input": {
          "asteroids": [
            8,
            -8
          ]
        },
        "output": []
      },
      {
        "input": {
          "asteroids": [
            10,
            2,
            -5
          ]
        },
        "output": [
          10
        ]
      },
      {
        "input": {
          "asteroids": [
            -2,
            -1,
            1,
            2
          ]
        },
        "output": [
          -2,
          -1,
          1,
          2
        ]
      },
      {
        "input": {
          "asteroids": [
            1,
            -2,
            -2,
            -2
          ]
        },
        "output": [
          -2,
          -2,
          -2
        ]
      },
      {
        "input": {
          "asteroids": [
            -2,
            -2,
            1,
            -2
          ]
        },
        "output": [
          -2,
          -2,
          -2
        ]
      },
      {
        "input": {
          "asteroids": [
            1,
            -1,
            -2,
            -2
          ]
        },
        "output": [
          -2,
          -2
        ]
      },
      {
        "input": {
          "asteroids": [
            1,
            2,
            3,
            -3,
            4,
            -4,
            5
          ]
        },
        "output": [
          1,
          2,
          5
        ]
      },
      {
        "input": {
          "asteroids": [
            -5,
            5
          ]
        },
        "output": [
          -5,
          5
        ]
      },
      {
        "input": {
          "asteroids": [
            1000,
            -1000
          ]
        },
        "output": []
      }
    ],
    "title": "Asteroid Collision",
    "metaData": {},
    "outputParameters": "List[integer]"
  },
  {
    "category": [
      "String",
      "Greedy",
      "Queue"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>In the world of Dota2, there are two parties: the Radiant and the Dire.</p>\n\n<p>The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <strong>one</strong> of the two rights:</p>\n\n<ul>\n\t<li><strong>Ban one senator&#39;s right:</strong> A senator can make another senator lose all his rights in this and all the following rounds.</li>\n\t<li><strong>Announce the victory:</strong> If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.</li>\n</ul>\n\n<p>Given a string <code>senate</code> representing each senator&#39;s party belonging. The character <code>&#39;R&#39;</code> and <code>&#39;D&#39;</code> represent the Radiant party and the Dire party. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.</p>\n\n<p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p>\n\n<p>Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be <code>&quot;Radiant&quot;</code> or <code>&quot;Dire&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> senate = &quot;RD&quot;\n<strong>Output:</strong> &quot;Radiant&quot;\n<strong>Explanation:</strong> \nThe first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. \nAnd the second senator can&#39;t exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> senate = &quot;RDD&quot;\n<strong>Output:</strong> &quot;Dire&quot;\n<strong>Explanation:</strong> \nThe first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. \nAnd the second senator can&#39;t exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator&#39;s right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == senate.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>senate[i]</code> is either <code>&#39;R&#39;</code> or <code>&#39;D&#39;</code>.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "predictPartyVictory",
    "inputParameters": {
      "cpp": {
        "senate": "string"
      },
      "java": {
        "senate": "String"
      },
      "javascript": {
        "senate": "string"
      },
      "python": {
        "senate": "str"
      }
    },
    "tests": [
      {
        "input": {
          "senate": "RD"
        },
        "output": "Radiant"
      },
      {
        "input": {
          "senate": "RDD"
        },
        "output": "Dire"
      },
      {
        "input": {
          "senate": "DDRRR"
        },
        "output": "Radiant"
      },
      {
        "input": {
          "senate": "DRRDRDRDRDDR"
        },
        "output": "Dire"
      },
      {
        "input": {
          "senate": "RRRDDDD"
        },
        "output": "Radiant"
      },
      {
        "input": {
          "senate": "DDDDDDRRRRRR"
        },
        "output": "Dire"
      },
      {
        "input": {
          "senate": "R"
        },
        "output": "Radiant"
      },
      {
        "input": {
          "senate": "D"
        },
        "output": "Dire"
      },
      {
        "input": {
          "senate": "RDRDRDRDRDRDRDRDRD"
        },
        "output": "Radiant"
      },
      {
        "input": {
          "senate": "DRDRDRDRDRDRDRDRDRD"
        },
        "output": "Dire"
      }
    ],
    "title": "Dota2 Senate",
    "metaData": {},
    "outputParameters": "string"
  },
  {
    "category": [
      "Linked List",
      "Two Pointers"
    ],
    "difficulty": 2,
    "evalMode": "listNodeIter",
    "question": "<p>You are given the <code>head</code> of a linked list. <strong>Delete</strong> the <strong>middle node</strong>, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>\n\n<p>The <strong>middle node</strong> of a linked list of size <code>n</code> is the <code>&lfloor;n / 2&rfloor;<sup>th</sup></code> node from the <b>start</b> using <strong>0-based indexing</strong>, where <code>&lfloor;x&rfloor;</code> denotes the largest integer less than or equal to <code>x</code>.</p>\n\n<ul>\n\t<li>For <code>n</code> = <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>, the middle nodes are <code>0</code>, <code>1</code>, <code>1</code>, <code>2</code>, and <code>2</code>, respectively.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" />\n<pre>\n<strong>Input:</strong> head = [1,3,4,7,1,2,6]\n<strong>Output:</strong> [1,3,4,1,2,6]\n<strong>Explanation:</strong>\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong>\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" />\n<pre>\n<strong>Input:</strong> head = [2,1]\n<strong>Output:</strong> [2]\n<strong>Explanation:</strong>\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "deleteMiddleNode",
    "inputParameters": {
      "cpp": {
        "head": "ListNode*"
      },
      "java": {
        "head": "ListNode"
      },
      "javascript": {
        "head": "ListNode"
      },
      "python": {
        "head": "Optional[ListNode]"
      }
    },
    "tests": [
      {
        "input": {
          "head": [
            1,
            3,
            4,
            7,
            1,
            2,
            6
          ]
        },
        "output": [
          1,
          3,
          4,
          1,
          2,
          6
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4
          ]
        },
        "output": [
          1,
          2,
          4
        ]
      },
      {
        "input": {
          "head": [
            2,
            1
          ]
        },
        "output": [
          2
        ]
      },
      {
        "input": {
          "head": [
            1
          ]
        },
        "output": []
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "output": [
          1,
          2,
          4,
          5
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6
          ]
        },
        "output": [
          1,
          2,
          3,
          5,
          6
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3
          ]
        },
        "output": [
          1,
          3
        ]
      },
      {
        "input": {
          "head": [
            1,
            2
          ]
        },
        "output": [
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9
          ]
        },
        "output": [
          1,
          2,
          3,
          4,
          6,
          7,
          8,
          9
        ]
      },
      {
        "input": {
          "head": [
            10,
            20,
            30,
            40,
            50,
            60,
            70,
            80,
            90,
            100
          ]
        },
        "output": [
          10,
          20,
          30,
          40,
          60,
          70,
          80,
          90,
          100
        ]
      }
    ],
    "title": "Delete the Middle Node of a Linked List",
    "metaData": {},
    "outputParameters": "List[integer]"
  },
  {
    "category": [
      "Linked List"
    ],
    "difficulty": 2,
    "evalMode": "listNodeIter",
    "question": "<p>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p>\n\n<p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p>\n\n<p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p>\n\n<p>You must solve the problem&nbsp;in <code>O(1)</code>&nbsp;extra space complexity and <code>O(n)</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg\" style=\"width: 300px; height: 123px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,3,5,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [2,1,3,5,6,4,7]\n<strong>Output:</strong> [2,3,6,7,1,5,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the linked list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>6</sup> &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "reorderOddEvenLinkedList",
    "inputParameters": {
      "cpp": {
        "head": "ListNode*"
      },
      "java": {
        "head": "ListNode"
      },
      "javascript": {
        "head": "ListNode"
      },
      "python": {
        "head": "Optional[ListNode]"
      }
    },
    "tests": [
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "output": [
          1,
          3,
          5,
          2,
          4
        ]
      },
      {
        "input": {
          "head": [
            2,
            1,
            3,
            5,
            6,
            4,
            7
          ]
        },
        "output": [
          2,
          3,
          6,
          7,
          1,
          5,
          4
        ]
      },
      {
        "input": {
          "head": [
            1
          ]
        },
        "output": [
          1
        ]
      },
      {
        "input": {
          "head": []
        },
        "output": []
      },
      {
        "input": {
          "head": [
            1,
            2
          ]
        },
        "output": [
          1,
          2
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3
          ]
        },
        "output": [
          1,
          3,
          2
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ]
        },
        "output": [
          1,
          3,
          5,
          7,
          9,
          2,
          4,
          6,
          8,
          10
        ]
      },
      {
        "input": {
          "head": [
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ]
        },
        "output": [
          10,
          8,
          6,
          4,
          2,
          9,
          7,
          5,
          3,
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            1,
            1,
            1,
            1
          ]
        },
        "output": [
          1,
          1,
          1,
          1,
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9
          ]
        },
        "output": [
          1,
          3,
          5,
          7,
          9,
          2,
          4,
          6,
          8
        ]
      }
    ],
    "title": "Odd Even Linked List",
    "metaData": {},
    "outputParameters": "List[integer]"
  },
  {
    "category": [
      "Linked List",
      "Recursion"
    ],
    "difficulty": 1,
    "evalMode": "listNodeIter",
    "question": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [5,4,3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n",
    "solutions": {},
    "functionName": "reverseLinkedList",
    "inputParameters": {
      "cpp": {
        "head": "ListNode*"
      },
      "java": {
        "head": "ListNode"
      },
      "javascript": {
        "head": "ListNode"
      },
      "python": {
        "head": "Optional[ListNode]"
      }
    },
    "tests": [
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        "output": [
          5,
          4,
          3,
          2,
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2
          ]
        },
        "output": [
          2,
          1
        ]
      },
      {
        "input": {
          "head": []
        },
        "output": []
      },
      {
        "input": {
          "head": [
            1
          ]
        },
        "output": [
          1
        ]
      },
      {
        "input": {
          "head": [
            1,
            1,
            1,
            1,
            1
          ]
        },
        "output": [
          1,
          1,
          1,
          1,
          1
        ]
      },
      {
        "input": {
          "head": [
            -1,
            -2,
            -3,
            -4,
            -5
          ]
        },
        "output": [
          -5,
          -4,
          -3,
          -2,
          -1
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            4,
            3,
            2,
            1
          ]
        },
        "output": [
          1,
          2,
          3,
          4,
          5,
          4,
          3,
          2,
          1
        ]
      },
      {
        "input": {
          "head": [
            0
          ]
        },
        "output": [
          0
        ]
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ]
        },
        "output": [
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ]
      },
      {
        "input": {
          "head": [
            -5000,
            0,
            5000
          ]
        },
        "output": [
          5000,
          0,
          -5000
        ]
      }
    ],
    "title": "Reverse Linked List",
    "metaData": {},
    "outputParameters": "List[integer]"
  },
  {
    "category": [
      "Linked List",
      "Two Pointers",
      "Stack"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>In a linked list of size <code>n</code>, where <code>n</code> is <strong>even</strong>, the <code>i<sup>th</sup></code> node (<strong>0-indexed</strong>) of the linked list is known as the <strong>twin</strong> of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.</p>\n\n<ul>\n\t<li>For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.</li>\n</ul>\n\n<p>The <strong>twin sum </strong>is defined as the sum of a node and its twin.</p>\n\n<p>Given the <code>head</code> of a linked list with even length, return <em>the <strong>maximum twin sum</strong> of the linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\" />\n<pre>\n<strong>Input:</strong> head = [5,4,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nNodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\nThere are no other nodes with twins in the linked list.\nThus, the maximum twin sum of the linked list is 6. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,2,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\nThe nodes with twins present in this linked list are:\n- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\nThus, the maximum twin sum of the linked list is max(7, 4) = 7. \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\" />\n<pre>\n<strong>Input:</strong> head = [1,100000]\n<strong>Output:</strong> 100001\n<strong>Explanation:</strong>\nThere is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is an <strong>even</strong> integer in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "findMaxTwinSum",
    "inputParameters": {
      "cpp": {
        "head": "ListNode*"
      },
      "java": {
        "head": "ListNode"
      },
      "javascript": {
        "head": "ListNode"
      },
      "python": {
        "head": "Optional[ListNode]"
      }
    },
    "tests": [
      {
        "input": {
          "head": [
            5,
            4,
            2,
            1
          ]
        },
        "output": 6
      },
      {
        "input": {
          "head": [
            4,
            2,
            2,
            3
          ]
        },
        "output": 7
      },
      {
        "input": {
          "head": [
            1,
            100000
          ]
        },
        "output": 100001
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6
          ]
        },
        "output": 7
      },
      {
        "input": {
          "head": [
            10,
            9,
            8,
            7,
            6,
            5
          ]
        },
        "output": 15
      },
      {
        "input": {
          "head": [
            1,
            1,
            1,
            1
          ]
        },
        "output": 2
      },
      {
        "input": {
          "head": [
            100,
            1,
            100,
            1
          ]
        },
        "output": 101
      },
      {
        "input": {
          "head": [
            5,
            5,
            5,
            5,
            5,
            5
          ]
        },
        "output": 10
      },
      {
        "input": {
          "head": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8
          ]
        },
        "output": 9
      },
      {
        "input": {
          "head": [
            99999,
            1,
            2,
            3,
            4,
            100000
          ]
        },
        "output": 199999
      }
    ],
    "title": "Maximum Twin Sum of a Linked List",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>\n\n<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>\n\n<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1],[2],[3],[]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "canVisitAllRooms",
    "inputParameters": {
      "cpp": {
        "rooms": "vector<vector<int>>"
      },
      "java": {
        "rooms": "List<List<Integer>>"
      },
      "javascript": {
        "rooms": "number[][]"
      },
      "python": {
        "rooms": "List[List[int]]"
      }
    },
    "tests": [
      {
        "input": {
          "rooms": [
            [
              1
            ],
            [
              2
            ],
            [
              3
            ],
            []
          ]
        },
        "output": true
      },
      {
        "input": {
          "rooms": [
            [
              1,
              3
            ],
            [
              3,
              0,
              1
            ],
            [
              2
            ],
            [
              0
            ]
          ]
        },
        "output": false
      },
      {
        "input": {
          "rooms": [
            [
              1,
              2,
              3
            ],
            [],
            [],
            []
          ]
        },
        "output": true
      },
      {
        "input": {
          "rooms": [
            [
              1
            ],
            [
              2
            ],
            [
              3
            ],
            [
              4
            ],
            []
          ]
        },
        "output": true
      },
      {
        "input": {
          "rooms": [
            [],
            []
          ]
        },
        "output": false
      },
      {
        "input": {
          "rooms": [
            [
              1
            ],
            []
          ]
        },
        "output": true
      },
      {
        "input": {
          "rooms": [
            [
              2
            ],
            [],
            [
              1
            ]
          ]
        },
        "output": false
      },
      {
        "input": {
          "rooms": [
            [
              1,
              2,
              3
            ],
            [
              2,
              3
            ],
            [
              3,
              1
            ],
            []
          ]
        },
        "output": true
      },
      {
        "input": {
          "rooms": [
            [
              1
            ],
            [
              2
            ],
            [
              0
            ]
          ]
        },
        "output": true
      },
      {
        "input": {
          "rooms": [
            [],
            [
              2,
              3
            ],
            [
              1,
              3
            ],
            [
              1,
              2
            ]
          ]
        },
        "output": false
      }
    ],
    "title": "Keys and Rooms",
    "metaData": {},
    "outputParameters": "boolean"
  },
  {
    "category": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>\n\n<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>\n\n<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>i<sup>th</sup></code> city and the <code>j<sup>th</sup></code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>\n\n<p>Return <em>the total number of <strong>provinces</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.</li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "countProvinces",
    "inputParameters": {
      "cpp": {
        "isConnected": "vector<vector<int>>"
      },
      "java": {
        "isConnected": "int[][]"
      },
      "javascript": {
        "isConnected": "number[][]"
      },
      "python": {
        "isConnected": "List[List[int]]"
      }
    },
    "tests": [
      {
        "input": {
          "isConnected": [
            [
              1,
              1,
              0
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              0,
              1
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ]
          ]
        },
        "output": 3
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ]
        },
        "output": 1
      },
      {
        "input": {
          "isConnected": [
            [
              1
            ]
          ]
        },
        "output": 1
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              0
            ],
            [
              0,
              1
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              1,
              0,
              0
            ],
            [
              1,
              1,
              0,
              0
            ],
            [
              0,
              0,
              1,
              1
            ],
            [
              0,
              0,
              1,
              1
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              0,
              0,
              1
            ],
            [
              0,
              1,
              1,
              0
            ],
            [
              0,
              1,
              1,
              1
            ],
            [
              1,
              0,
              1,
              1
            ]
          ]
        },
        "output": 1
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              0,
              0,
              0,
              0
            ],
            [
              0,
              1,
              0,
              0,
              0
            ],
            [
              0,
              0,
              1,
              0,
              0
            ],
            [
              0,
              0,
              0,
              1,
              0
            ],
            [
              0,
              0,
              0,
              0,
              1
            ]
          ]
        },
        "output": 5
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              1,
              1,
              0,
              0
            ],
            [
              1,
              1,
              1,
              0,
              0
            ],
            [
              1,
              1,
              1,
              0,
              0
            ],
            [
              0,
              0,
              0,
              1,
              1
            ],
            [
              0,
              0,
              0,
              1,
              1
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "isConnected": [
            [
              1,
              0,
              1,
              0
            ],
            [
              0,
              1,
              0,
              1
            ],
            [
              1,
              0,
              1,
              0
            ],
            [
              0,
              1,
              0,
              1
            ]
          ]
        },
        "output": 2
      }
    ],
    "title": "Number of Provinces",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.</p>\n\n<p>Roads are represented by <code>connections</code> where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a road from city <code>a<sub>i</sub></code> to city <code>b<sub>i</sub></code>.</p>\n\n<p>This year, there will be a big event in the capital (city <code>0</code>), and many people want to travel to this city.</p>\n\n<p>Your task consists of reorienting some roads such that each city can visit the city <code>0</code>. Return the <strong>minimum</strong> number of edges changed.</p>\n\n<p>It&#39;s <strong>guaranteed</strong> that each city can reach city <code>0</code> after reorder.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png\" style=\"width: 311px; height: 189px;\" />\n<pre>\n<strong>Input:</strong> n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>Change the direction of edges show in red such that each node can reach the node 0 (capital).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png\" style=\"width: 509px; height: 79px;\" />\n<pre>\n<strong>Input:</strong> n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>Change the direction of edges show in red such that each node can reach the node 0 (capital).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, connections = [[1,0],[2,0]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>connections.length == n - 1</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "minReorderToReachCapital",
    "inputParameters": {
      "cpp": {
        "n": "int",
        "connections": "vector<vector<int>>"
      },
      "java": {
        "n": "int",
        "connections": "int[][]"
      },
      "javascript": {
        "n": "number",
        "connections": "number[][]"
      },
      "python": {
        "n": "int",
        "connections": "List[List[int]]"
      }
    },
    "tests": [
      {
        "input": {
          "n": 6,
          "connections": [
            [
              0,
              1
            ],
            [
              1,
              3
            ],
            [
              2,
              3
            ],
            [
              4,
              0
            ],
            [
              4,
              5
            ]
          ]
        },
        "output": 3
      },
      {
        "input": {
          "n": 5,
          "connections": [
            [
              1,
              0
            ],
            [
              1,
              2
            ],
            [
              3,
              2
            ],
            [
              3,
              4
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "n": 3,
          "connections": [
            [
              1,
              0
            ],
            [
              2,
              0
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "n": 4,
          "connections": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              2,
              3
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "n": 7,
          "connections": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              2,
              3
            ],
            [
              3,
              4
            ],
            [
              4,
              5
            ],
            [
              5,
              6
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "n": 8,
          "connections": [
            [
              1,
              0
            ],
            [
              2,
              1
            ],
            [
              3,
              2
            ],
            [
              4,
              3
            ],
            [
              5,
              4
            ],
            [
              6,
              5
            ],
            [
              7,
              6
            ]
          ]
        },
        "output": 7
      },
      {
        "input": {
          "n": 10,
          "connections": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              2,
              3
            ],
            [
              3,
              4
            ],
            [
              4,
              5
            ],
            [
              5,
              6
            ],
            [
              6,
              7
            ],
            [
              7,
              8
            ],
            [
              8,
              9
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "n": 9,
          "connections": [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              2,
              3
            ],
            [
              3,
              4
            ],
            [
              4,
              5
            ],
            [
              5,
              6
            ],
            [
              6,
              7
            ],
            [
              7,
              8
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "n": 5,
          "connections": [
            [
              1,
              0
            ],
            [
              2,
              1
            ],
            [
              3,
              1
            ],
            [
              4,
              3
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "n": 7,
          "connections": [
            [
              0,
              1
            ],
            [
              0,
              2
            ],
            [
              1,
              3
            ],
            [
              1,
              4
            ],
            [
              2,
              5
            ],
            [
              2,
              6
            ]
          ]
        },
        "output": 0
      }
    ],
    "title": "Reorder Routes to Make All Paths Lead to the City Zero",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "String",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph",
      "Shortest Path"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>\n\n<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>\n\n<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>\n\n<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>\n\n<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>Explanation:</strong> \nGiven: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>\nqueries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined =&gt; -1.0</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "calculateVariableRatios",
    "inputParameters": {
      "cpp": {
        "equations": "vector<vector<string>>",
        "values": "vector<double>",
        "queries": "vector<vector<string>>"
      },
      "java": {
        "equations": "List<List<String>>",
        "values": "double[]",
        "queries": "List<List<String>>"
      },
      "javascript": {
        "equations": "string[][]",
        "values": "number[]",
        "queries": "string[][]"
      },
      "python": {
        "equations": "List[List[str]]",
        "values": "List[float]",
        "queries": "List[List[str]]"
      }
    },
    "tests": [
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ],
            [
              "b",
              "c"
            ]
          ],
          "values": [
            2.0,
            3.0
          ],
          "queries": [
            [
              "a",
              "c"
            ],
            [
              "b",
              "a"
            ],
            [
              "a",
              "e"
            ],
            [
              "a",
              "a"
            ],
            [
              "x",
              "x"
            ]
          ]
        },
        "output": [
          6.0,
          0.5,
          -1.0,
          1.0,
          -1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ],
            [
              "b",
              "c"
            ],
            [
              "bc",
              "cd"
            ]
          ],
          "values": [
            1.5,
            2.5,
            5.0
          ],
          "queries": [
            [
              "a",
              "c"
            ],
            [
              "c",
              "b"
            ],
            [
              "bc",
              "cd"
            ],
            [
              "cd",
              "bc"
            ]
          ]
        },
        "output": [
          3.75,
          0.4,
          5.0,
          0.2
        ]
      },
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ]
          ],
          "values": [
            0.5
          ],
          "queries": [
            [
              "a",
              "b"
            ],
            [
              "b",
              "a"
            ],
            [
              "a",
              "c"
            ],
            [
              "x",
              "y"
            ]
          ]
        },
        "output": [
          0.5,
          2.0,
          -1.0,
          -1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "x",
              "y"
            ],
            [
              "y",
              "z"
            ]
          ],
          "values": [
            2.0,
            3.0
          ],
          "queries": [
            [
              "x",
              "z"
            ],
            [
              "z",
              "x"
            ],
            [
              "y",
              "y"
            ],
            [
              "z",
              "z"
            ],
            [
              "x",
              "w"
            ]
          ]
        },
        "output": [
          6.0,
          0.16667,
          1.0,
          1.0,
          -1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ],
            [
              "c",
              "d"
            ]
          ],
          "values": [
            1.0,
            1.0
          ],
          "queries": [
            [
              "a",
              "c"
            ],
            [
              "b",
              "d"
            ],
            [
              "b",
              "a"
            ],
            [
              "d",
              "c"
            ]
          ]
        },
        "output": [
          -1.0,
          -1.0,
          1.0,
          1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ],
            [
              "b",
              "c"
            ],
            [
              "c",
              "d"
            ],
            [
              "d",
              "e"
            ]
          ],
          "values": [
            2.0,
            3.0,
            4.0,
            5.0
          ],
          "queries": [
            [
              "a",
              "e"
            ],
            [
              "e",
              "a"
            ],
            [
              "b",
              "e"
            ],
            [
              "a",
              "a"
            ]
          ]
        },
        "output": [
          120.0,
          0.00833,
          60.0,
          1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "x1",
              "x2"
            ],
            [
              "x2",
              "x3"
            ],
            [
              "x3",
              "x4"
            ],
            [
              "x4",
              "x5"
            ]
          ],
          "values": [
            3.0,
            4.0,
            5.0,
            6.0
          ],
          "queries": [
            [
              "x1",
              "x5"
            ],
            [
              "x5",
              "x2"
            ],
            [
              "x2",
              "x4"
            ]
          ]
        },
        "output": [
          360.0,
          0.00833,
          20.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ],
            [
              "b",
              "c"
            ]
          ],
          "values": [
            2.0,
            3.0
          ],
          "queries": [
            [
              "a",
              "c"
            ],
            [
              "c",
              "a"
            ],
            [
              "b",
              "b"
            ],
            [
              "c",
              "c"
            ]
          ]
        },
        "output": [
          6.0,
          0.16667,
          1.0,
          1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "x",
              "y"
            ]
          ],
          "values": [
            2.0
          ],
          "queries": [
            [
              "x",
              "y"
            ],
            [
              "y",
              "x"
            ],
            [
              "y",
              "y"
            ],
            [
              "x",
              "x"
            ],
            [
              "z",
              "x"
            ]
          ]
        },
        "output": [
          2.0,
          0.5,
          1.0,
          1.0,
          -1.0
        ]
      },
      {
        "input": {
          "equations": [
            [
              "a",
              "b"
            ],
            [
              "b",
              "c"
            ],
            [
              "a",
              "c"
            ]
          ],
          "values": [
            2.0,
            3.0,
            6.0
          ],
          "queries": [
            [
              "a",
              "c"
            ],
            [
              "b",
              "a"
            ],
            [
              "a",
              "e"
            ],
            [
              "a",
              "a"
            ],
            [
              "x",
              "x"
            ]
          ]
        },
        "output": [
          6.0,
          0.5,
          -1.0,
          1.0,
          -1.0
        ]
      }
    ],
    "title": "Evaluate Division",
    "metaData": {},
    "outputParameters": "List[float]"
  },
  {
    "category": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>You are given an <code>m x n</code> matrix <code>maze</code> (<strong>0-indexed</strong>) with empty cells (represented as <code>&#39;.&#39;</code>) and walls (represented as <code>&#39;+&#39;</code>). You are also given the <code>entrance</code> of the maze, where <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> denotes the row and column of the cell you are initially standing at.</p>\n\n<p>In one step, you can move one cell <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the <strong>nearest exit</strong> from the <code>entrance</code>. An <strong>exit</strong> is defined as an <strong>empty cell</strong> that is at the <strong>border</strong> of the <code>maze</code>. The <code>entrance</code> <strong>does not count</strong> as an exit.</p>\n\n<p>Return <em>the <strong>number of steps</strong> in the shortest path from the </em><code>entrance</code><em> to the nearest exit, or </em><code>-1</code><em> if no such path exists</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg\" style=\"width: 333px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> maze = [[&quot;+&quot;,&quot;+&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;+&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;,&quot;.&quot;]], entrance = [1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There are 3 exits in this maze at [1,0], [0,2], and [2,3].\nInitially, you are at the entrance cell [1,2].\n- You can reach [1,0] by moving 2 steps left.\n- You can reach [0,2] by moving 1 step up.\nIt is impossible to reach [2,3] from the entrance.\nThus, the nearest exit is [0,2], which is 1 step away.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> maze = [[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;+&quot;,&quot;+&quot;,&quot;+&quot;]], entrance = [1,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There is 1 exit in this maze at [1,2].\n[1,0] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell [1,0].\n- You can reach [1,2] by moving 2 steps right.\nThus, the nearest exit is [1,2], which is 2 steps away.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg\" style=\"width: 173px; height: 93px;\" />\n<pre>\n<strong>Input:</strong> maze = [[&quot;.&quot;,&quot;+&quot;]], entrance = [0,0]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There are no exits in this maze.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>maze.length == m</code></li>\n\t<li><code>maze[i].length == n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>maze[i][j]</code> is either <code>&#39;.&#39;</code> or <code>&#39;+&#39;</code>.</li>\n\t<li><code>entrance.length == 2</code></li>\n\t<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>\n\t<li><code>entrance</code> will always be an empty cell.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "findNearestMazeExit",
    "inputParameters": {
      "cpp": {
        "maze": "vector<vector<char>>",
        "entrance": "vector<int>"
      },
      "java": {
        "maze": "char[][]",
        "entrance": "int[]"
      },
      "javascript": {
        "maze": "character[][]",
        "entrance": "number[]"
      },
      "python": {
        "maze": "List[List[str]]",
        "entrance": "List[int]"
      }
    },
    "tests": [
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              ".",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              "+"
            ],
            [
              "+",
              "+",
              "+",
              "."
            ]
          ],
          "entrance": [
            1,
            2
          ]
        },
        "output": 1
      },
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              "+"
            ],
            [
              ".",
              ".",
              "."
            ],
            [
              "+",
              " +",
              "+"
            ]
          ],
          "entrance": [
            1,
            0
          ]
        },
        "output": 2
      },
      {
        "input": {
          "maze": [
            [
              ".",
              "+"
            ]
          ],
          "entrance": [
            0,
            0
          ]
        },
        "output": -1
      },
      {
        "input": {
          "maze": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              "+",
              "+",
              "+",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "entrance": [
            0,
            0
          ]
        },
        "output": 1
      },
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              "+",
              "+",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              ".",
              "+"
            ],
            [
              "+",
              "+",
              "+",
              ".",
              "+"
            ]
          ],
          "entrance": [
            1,
            2
          ]
        },
        "output": 3
      },
      {
        "input": {
          "maze": [
            [
              "."
            ]
          ],
          "entrance": [
            0,
            0
          ]
        },
        "output": 0
      },
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              "+"
            ],
            [
              ".",
              ".",
              "."
            ],
            [
              "+",
              "+",
              "+"
            ]
          ],
          "entrance": [
            1,
            1
          ]
        },
        "output": 1
      },
      {
        "input": {
          "maze": [
            [
              "+",
              ".",
              "+",
              "+",
              "+",
              "+",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              ".",
              ".",
              ".",
              "+"
            ],
            [
              "+",
              ".",
              ".",
              "+",
              "+",
              ".",
              "+"
            ],
            [
              "+",
              "+",
              "+",
              "+",
              "+",
              ".",
              "+"
            ],
            [
              "+",
              ".",
              ".",
              ".",
              ".",
              ".",
              "+"
            ]
          ],
          "entrance": [
            0,
            1
          ]
        },
        "output": 7
      },
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              "+",
              "+",
              "+",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              ".",
              ".",
              "+"
            ],
            [
              ".",
              "+",
              "+",
              "+",
              ".",
              "+"
            ],
            [
              ".",
              "+",
              ".",
              ".",
              ".",
              "+"
            ],
            [
              ".",
              "+",
              "+",
              "+",
              ".",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              ".",
              ".",
              "+"
            ]
          ],
          "entrance": [
            1,
            0
          ]
        },
        "output": 10
      },
      {
        "input": {
          "maze": [
            [
              "+",
              "+",
              "+",
              "+",
              "+"
            ],
            [
              ".",
              ".",
              ".",
              ".",
              "."
            ],
            [
              "+",
              "+",
              "+",
              "+",
              "+"
            ]
          ],
          "entrance": [
            1,
            2
          ]
        },
        "output": 2
      }
    ],
    "title": "Nearest Exit from Entrance in Maze",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Breadth-First Search",
      "Matrix"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p>\n\n<ul>\n\t<li><code>0</code> representing an empty cell,</li>\n\t<li><code>1</code> representing a fresh orange, or</li>\n\t<li><code>2</code> representing a rotten orange.</li>\n</ul>\n\n<p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p>\n\n<p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\" style=\"width: 650px; height: 137px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,1,1],[1,1,0],[0,1,1]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[2,1,1],[0,1,1],[1,0,1]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,2]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Since there are already no fresh oranges at minute 0, the answer is just 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>grid[i][j]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n",
    "solutions": {},
    "functionName": "getMinutesToRotAllOranges",
    "inputParameters": {
      "cpp": {
        "grid": "vector<vector<int>>"
      },
      "java": {
        "grid": "int[][]"
      },
      "javascript": {
        "grid": "number[][]"
      },
      "python": {
        "grid": "List[List[int]]"
      }
    },
    "tests": [
      {
        "input": {
          "grid": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ]
        },
        "output": 4
      },
      {
        "input": {
          "grid": [
            [
              2,
              1,
              1
            ],
            [
              0,
              1,
              1
            ],
            [
              1,
              0,
              1
            ]
          ]
        },
        "output": -1
      },
      {
        "input": {
          "grid": [
            [
              0,
              2
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "grid": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ]
        },
        "output": -1
      },
      {
        "input": {
          "grid": [
            [
              2,
              2,
              2
            ],
            [
              2,
              2,
              2
            ],
            [
              2,
              2,
              2
            ]
          ]
        },
        "output": 0
      },
      {
        "input": {
          "grid": [
            [
              1,
              2,
              1
            ],
            [
              1,
              2,
              1
            ],
            [
              1,
              2,
              1
            ]
          ]
        },
        "output": 1
      },
      {
        "input": {
          "grid": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              2
            ]
          ]
        },
        "output": 2
      },
      {
        "input": {
          "grid": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ]
        },
        "output": -1
      },
      {
        "input": {
          "grid": [
            [
              2,
              1,
              1,
              1,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              1,
              1,
              1,
              2
            ]
          ]
        },
        "output": 4
      },
      {
        "input": {
          "grid": [
            [
              1
            ]
          ]
        },
        "output": -1
      }
    ],
    "title": "Rotting Oranges",
    "metaData": {},
    "outputParameters": "integer"
  },
  {
    "category": [
      "Array",
      "Divide and Conquer",
      "Sorting",
      "Heap (Priority Queue)",
      "Quickselect"
    ],
    "difficulty": 2,
    "evalMode": "exactMatch",
    "question": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>largest element in the array</em>.</p>\n\n<p>Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>\n\n<p>Can you solve it without sorting?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2\n<strong>Output:</strong> 5\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4\n<strong>Output:</strong> 4\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "solutions": {},
    "functionName": "findKthLargestElement",
    "inputParameters": {
      "cpp": {
        "nums": "vector<int>",
        "k": "int"
      },
      "java": {
        "nums": "int[]",
        "k": "int"
      },
      "javascript": {
        "nums": "number[]",
        "k": "number"
      },
      "python": {
        "nums": "List[int]",
        "k": "int"
      }
    },
    "tests": [
      {
        "input": {
          "nums": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "k": 2
        },
        "output": 5
      },
      {
        "input": {
          "nums": [
            3,
            2,
            3,
            1,
            2,
            4,
            5,
            5,
            6
          ],
          "k": 4
        },
        "output": 4
      },
      {
        "input": {
          "nums": [
            1
          ],
          "k": 1
        },
        "output": 1
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ],
          "k": 1
        },
        "output": 10
      },
      {
        "input": {
          "nums": [
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
          ],
          "k": 10
        },
        "output": 1
      },
      {
        "input": {
          "nums": [
            -1,
            -2,
            -3,
            -4,
            -5
          ],
          "k": 3
        },
        "output": -3
      },
      {
        "input": {
          "nums": [
            5,
            5,
            5,
            5,
            5
          ],
          "k": 3
        },
        "output": 5
      },
      {
        "input": {
          "nums": [
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5
          ],
          "k": 5
        },
        "output": 3
      },
      {
        "input": {
          "nums": [
            10000,
            -10000,
            0,
            1,
            -1
          ],
          "k": 2
        },
        "output": 1
      },
      {
        "input": {
          "nums": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10
          ],
          "k": 5
        },
        "output": 6
      }
    ],
    "title": "Kth Largest Element in an Array",
    "metaData": {},
    "outputParameters": "integer"
  }
]